#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This module contains the functions concerned with running the various SBC models
for the dendritic input project
@author: kuenzel{at}bio2.rwth-aachen.de
Created on Thu May 16 10:09:28 2019
Modifed sept 2020
"""

import numpy as np
import sehelper as seh
import pandas as pd
import xml.etree.ElementTree as ET
from neuron import h
import os

h.nrn_load_dll("./mechanisms/x86_64/.libs/libnrnmech.so")

# ===============================================================================


def SE_BS(
    S,
    Simdur=400.0,
    dt=0.01,
    G_EoH=0.055,
    StochasticEoH=True,
    N=32,
    G_Dend=0.016,
    tau_Dend=2.0,
    L=50.0,
    D=3.0,
    constR=False,
    gKLT_d=0.0085,
    gIH_d=0.001,
    gLEAK_d=0.001,
    gKLT_s=0.017,
    gIH_s=0.002,
    EoHseed=-1,
    somaticsynapsesonly=0,
    impedancetesting=0,
    impstim=(0.1, 50.0, 0.0),
    Ra=150.0,
):
    """
    1.builds an SBC with a soma, a proximal (dend1) and distal (dend2) dendrite
    and an somatic input (endbulb) and gives it biophysical parameters
    2.generates a GClamp input for the endbulb
    3.build synapses with netcon, spikes generated by a sound, and stimulates

    If you pass somaticsynapsesonly=1 then all the small synapses will be located on
    the soma (as requested by reviewer 2 for the JNP submission)

    If you pass impedancetesting=1, than a single current source will be attached to
    the distal end of the distal dendrite and a sinusoidal current of
    impstim[0] Amplitude,impstim[1] frequency and impstim[2] phase will be played.
    No synaptic events will occur in this case.
    """
    pretime = 100.0  # ms

    # Check for impedancetesting and if the user wants it, blank all synaptic inputs
    if impedancetesting == 1 or impedancetesting == -1:
        G_Dend = 0.0
        G_EoH = 0.0
        from scipy.signal import chirp

    # CREATE MODEL SECTIONS
    BCsoma = h.Section()
    BCaxonhillock = h.Section()
    BCaxonsegment = h.Section()
    dend1 = h.Section()
    dend2 = h.Section()

    # SECTION SETTINGS
    # dimensions
    BCsoma.L = 19.5
    BCsoma.diam = 19.5
    BCsoma.nseg = 9
    BCaxonhillock.L = 15
    BCaxonhillock.diam = 4
    BCaxonhillock.nseg = 3
    BCaxonsegment.L = 100
    BCaxonsegment.diam = 2
    BCaxonsegment.nseg = 10

    ###add dendrites
    dend1.L = L
    dend1.diam = D
    dend1.nseg = 21  # int(L)
    dend2.L = 50
    dend2.diam = 3
    dend2.nseg = 100
    # -----------get R of dend1 (for debug purposes)
    d1A = 0.0
    for seg in dend1.allseg():  # this is save for 3d data
        d1A = d1A + seg.area()

    # axial Resistance and cm
    for sec in h.allsec():
        sec.Ra = Ra
        sec.insert("extracellular")
    BCaxonsegment.cm = 0.1
    # na---------------------------------------------
    BCsoma.insert("na_fast")
    BCsoma.ena = 50
    BCsoma.gnabar_na_fast = 0.01
    BCaxonhillock.insert("na_fast")
    BCaxonhillock.ena = 50
    BCaxonhillock.gnabar_na_fast = 0.53
    # klt---------------------------------------------
    BCsoma.insert("klt")
    BCsoma.ek = -70
    BCsoma.gkltbar_klt = gKLT_s
    dend1.insert("klt")
    if constR:
        dend1.gkltbar_klt = (0.15 / d1A) * (gKLT_d * 1000.0)
    else:
        dend1.gkltbar_klt = gKLT_d
    # kht---------------------------------------------
    BCsoma.insert("kht")
    BCsoma.gkhtbar_kht = 0.013
    BCaxonhillock.insert("kht")
    BCaxonhillock.ek = -70
    BCaxonhillock.gkhtbar_kht = 0.01
    # ih---------------------------------------------
    BCsoma.insert("ih")
    h.eh_ih = -43
    BCsoma.ghbar_ih = gIH_s
    dend1.insert("ih")
    if constR:
        dend1.ghbar_ih = (0.15 / d1A) * (gIH_d * 1000.0)
    else:
        dend1.ghbar_ih = gIH_d
    # leak---------------------------------------------
    BCsoma.insert("leak")
    BCsoma.erev_leak = -65
    BCsoma.g_leak = 0.001
    BCaxonhillock.insert("leak")
    BCaxonhillock.erev_leak = -65
    BCaxonhillock.g_leak = 0.001
    BCaxonsegment.insert("leak")
    BCaxonsegment.erev_leak = -65
    BCaxonsegment.g_leak = 0.0001
    dend1.insert("leak")
    dend1.erev_leak = -65
    if constR:
        dend1.g_leak = 0.15 / d1A * (gLEAK_d * 1000.0)
    else:
        dend1.g_leak = gLEAK_d
    dend2.insert("leak")
    dend2.erev_leak = -65
    dend2.g_leak = 0.001

    # CONNECT SECTIONS (soma0-soma1..ah0-ah1..ax0-ax1)
    BCaxonsegment.connect(BCaxonhillock, 1, 0)
    BCaxonhillock.connect(BCsoma, 1, 0)
    BCsoma.connect(dend1, 1, 0)
    dend1.connect(dend2, 1, 0)

    # GENERAL SETTINGS
    h.dt = dt  # simulation (or "sampling") rate
    h.celsius = 35  # simulation global temperature

    # MODEL NEURON INPUTS
    if G_EoH != 0.0:
        g_exc = seh.make_g_trace(
            Simdur + pretime,
            dt,
            S[-1] + pretime,
            seh.g_template(dt=dt, gmax=G_EoH),
            StochasticEoH,
            0.1,
            EoHseed,
        )  # Last spiketimes are for endbulbs
        exc = h.Vector(g_exc)
        endbulb = h.GClamp(0.4, sec=BCsoma)
        endbulb.e = 0
        exc.play(endbulb._ref_g, h.dt)
    # ab hier synapsen anhängen
    if N != 0:
        vstim = []
        syna = []
        netcon = []
        G_i = G_Dend / N  # individual conductance
        pos = np.linspace(
            0.05, 0.95, N
        )  # gleichmässig verteilt über den verfügbaren dendriten
        for a in range(N):
            if somaticsynapsesonly == 1:
                syna.append(h.ExpSyn(BCsoma(pos[a])))
            else:
                syna.append(h.ExpSyn(dend2(pos[a])))
            syna[a].tau = tau_Dend
            # synapse stimulieren
            vstim.append(h.VecStim())
            netcon.append(h.NetCon(vstim[a], syna[a]))  # connect stimulus and synapse
            netcon[a].weight[0] = G_i
            spt = h.Vector(S[a] + pretime)
            vstim[a].play(spt)

    # Input for impedance testing (as requested by reviewer)
    if impedancetesting == 1 or impedancetesting == -1:
        impclamp = h.IClamp(dend2(0.99))
        impclamp.delay = 0.0
        impclamp.dur = 1e9
        impclamp.amp = 0.0
        if impedancetesting == -1:
            t = np.linspace(0.0, Simdur - dt, int(Simdur / dt))
            tsec = t / 1000.0
            impwave = impstim[0] * chirp(
                tsec,
                f0=impstim[1][0],
                f1=impstim[1][1],
                t1=tsec[-1],
                method="linear",
            )
        else:
            t = np.linspace(0.0, Simdur - dt, int(Simdur / dt))
            f = impstim[1] / 1000.0
            impwave = impstim[0] * np.sin(2.0 * np.pi * f * t + impstim[2])
        prezeros = np.zeros(int(round(pretime / dt)))
        impwave = np.concatenate((prezeros, impwave))
        impwave = h.Vector(impwave)
        tvec = np.linspace(0.0, (Simdur + pretime) - dt, (Simdur + pretime) / dt)
        tvec = h.Vector(tvec)
        impwave.play(impclamp._ref_amp, tvec)

    # INFRASTRUCTURE
    Vm = h.Vector()
    Vm.record(BCsoma(0.5)._ref_v)

    # ----------SIMULATE--------------
    h.finitialize(-63.79)
    h.fcurrent()
    while h.t < Simdur + pretime:
        h.fadvance()

    # PACK AND EXPORT DATA
    Result = {}
    tempres_vm = np.array(Vm)
    Result["Vm"] = tempres_vm[
        int(pretime / dt) : int((Simdur + pretime) / dt)
    ]  # remove "additional" samples

    # some debug info
    g_total_dend1 = dend1.g_leak + dend1.ghbar_ih + dend1.gkltbar_klt  # S/cm²
    g_total_dend1 = g_total_dend1 * (d1A * 1e-8) * 1e9
    # print('gDend1=' + str(g_total_dend1) + 'nS')

    # ---------KILL STUFF FOR (minimal) PERFORMANCE REASONS---------------------
    netcon = None
    vstim = None
    syna = None
    Vm = None
    spt = None
    BCaxonsegment = None
    BCaxonhillock = None
    BCsoma = None
    dend1 = None
    dend2 = None

    # ---------SAY GOODBYE-------------
    return Result


# ===============================================================================
# ===========================3D SBC Code below===================================
# ===============================================================================
def load3Dnew(cell="0119simple", minD=1.0, debug=False):
    """
    New version of the 3D loader for the cells. This function reads xml data that
    is generated by the "Simple Neurite Tracer"/FIJI, because in this data the
    3D-coordinates of path-segments and the path-identity is contained together, unlike
    the exported data.
    Note: SNT/FIJI .traces files are unreadable (probably caused by character encoding
    problems), but copying the content and saving as a regular utf-8 encoded text file
    (with .xml extension here) suffices.
    --Created october 2020, Thomas Künzel--
    """
    # ----------------------read XML-----------------------
    celldir = "./cells/" + cell + "/"
    fname = celldir + cell + ".xml"
    tree = ET.parse(fname)
    root = tree.getroot()
    # ----------------------generate pathlist (like the csv exported)------------------
    trueid = []
    ptype = []
    primary = []
    name = []
    swctype = []
    usefitted = []
    reallength = []
    pathid = []
    fittedversion = []
    startson = []
    startx = []
    starty = []
    startz = []
    for element in root:
        if element.tag == "path":
            trueid.append(int(element.get("id")))
            name.append(element.get("name"))
            swctype.append(int(element.get("swctype")))
            usefitted.append(bool(element.get("usefitted")))
            reallength.append(float(element.get("reallength")))
            if "Fitted" in name[-1]:
                pathid.append(int(element.get("fittedversionof")))
                ptype.append(1)
                fittedversion.append(np.nan)
                startson.append(np.nan)
                startx.append(np.nan)
                starty.append(np.nan)
                startz.append(np.nan)
                primary.append(0)
            else:
                ptype.append(0)
                pathid.append(int(element.get("id")))
                if element.get("startson") is None:
                    startson.append(np.nan)
                    primary.append(1)
                else:
                    startson.append(int(element.get("startson")))
                    primary.append(0)
                if element.get("startx") is None:
                    startx.append(np.nan)
                else:
                    startx.append(float(element.get("startx")))
                if element.get("starty") is None:
                    starty.append(np.nan)
                else:
                    starty.append(float(element.get("starty")))
                if element.get("startz") is None:
                    startz.append(np.nan)
                else:
                    startz.append(float(element.get("startz")))
                if element.get("fitted") is None:
                    fittedversion.append(np.nan)
                else:
                    fittedversion.append(int(element.get("fitted")))
    frame = {
        "pathid": pd.Series(pathid),
        "trueid": pd.Series(trueid),
        "ptype": pd.Series(ptype),
        "primary": pd.Series(primary),
        "name": pd.Series(name),
        "swctype": pd.Series(swctype),
        "usefitted": pd.Series(usefitted),
        "fittedversion": pd.Series(fittedversion),
        "startson": pd.Series(startson),
        "startx": pd.Series(startx),
        "starty": pd.Series(starty),
        "startz": pd.Series(startz),
        "reallength": pd.Series(reallength),
    }
    paths = pd.DataFrame(frame)
    # copy info from paths to corresponding fitted paths
    for myidx, row in paths.iterrows():
        if row.ptype == 1:
            row0 = paths[(paths["pathid"] == row.pathid) & (paths["ptype"] == 0)]
            paths.at[myidx, "primary"] = row0["primary"]
            paths.at[myidx, "startson"] = row0["startson"]
            paths.at[myidx, "startx"] = row0["startx"]
            paths.at[myidx, "starty"] = row0["starty"]
            paths.at[myidx, "startz"] = row0["startz"]
    if debug:
        xlsname = celldir + cell + "_pathlist.xls"
        paths.to_excel(xlsname)
    #
    # -----------generate swc-like point information for the fitted paths--------------
    pid = []
    pn = []
    swc = []
    xd = []
    yd = []
    zd = []
    r = []
    for element in root:
        if element.tag == "path":
            thisname = element.get("name")
            if "Fitted" in thisname:
                for point in element:
                    pid.append(int(element.get("fittedversionof")))
                    pn.append(thisname)
                    swc.append(int(element.get("swctype")))
                    xd.append(float(point.get("xd")))
                    yd.append(float(point.get("yd")))
                    zd.append(float(point.get("zd")))
                    r.append(float(point.get("r")))
    frame2 = {
        "pathid": pd.Series(pid),
        "name": pd.Series(pn),
        "swctype": pd.Series(swc),
        "xd": pd.Series(xd),
        "yd": pd.Series(yd),
        "zd": pd.Series(zd),
        "r": pd.Series(r),
    }
    parts = pd.DataFrame(frame2)
    if debug:
        xlsname = celldir + cell + "_3dpoints.xls"
        parts.to_excel(xlsname)
    #
    # split infos
    somas = paths.loc[(paths["swctype"] == 1) & (paths["ptype"] == 1)]
    somas.index = range(len(somas))
    axons = paths.loc[(paths["swctype"] == 2) & (paths["ptype"] == 1)]
    axons.index = range(len(axons))
    proximals = paths.loc[(paths["swctype"] == 3) & (paths["ptype"] == 1)]
    proximals.index = range(len(proximals))
    distals = paths.loc[(paths["swctype"] == 0) & (paths["ptype"] == 1)]
    distals.index = range(len(distals))
    somaparts = parts.loc[parts["swctype"] == 1].copy()
    axonparts = parts.loc[parts["swctype"] == 2].copy()
    proximalparts = parts.loc[parts["swctype"] == 3].copy()
    distalparts = parts.loc[parts["swctype"] == 0].copy()
    if minD != -1.0:  # apply minimum radius
        axonparts.loc[axonparts.r < minD, "r"] = minD
        proximalparts.loc[proximalparts.r < minD, "r"] = minD
        distalparts.loc[distalparts.r < minD, "r"] = minD
    # get soma diameter from special "somaD" path:
    somaD = paths.loc[paths["name"] == "somaD", "reallength"].values
    #
    # -------------------- create sections ---------------------------
    soma = h.Section(name="soma")
    soma.nseg = 7
    ais = h.Section(name="ais")
    ais.nseg = 3
    axon = h.Section(name="axon")
    axon.nseg = 11
    proximal = []
    for i in range(len(proximals)):
        Sec = h.Section(name="prox" + str(i))
        Sec.nseg = 5
        proximal.append(Sec)
    distal = []
    for i in range(len(distals)):
        Sec = h.Section(name="dist" + str(i))
        Sec.nseg = 5
        distal.append(Sec)
    #
    # ----------------3D-define and connect Sections-------------------
    ais.connect(soma(0), 0)  # ais opposite of soma
    axon.connect(ais(1), 0)
    # first we assign a stylized soma<->ais<->axon to the model for comparability with
    # the ball and stick model! This allows for isolated analysis of the dendrite:
    h.pt3dclear(sec=soma)
    soma_x0 = somaparts["xd"].values[0]
    soma_y0 = somaparts["yd"].values[0]
    soma_z0 = somaparts["zd"].values[0]
    soma_d = 19.5
    h.pt3dadd(soma_x0, soma_y0, soma_z0, soma_d, sec=soma)
    h.pt3dadd(soma_x0 + 19.5, soma_y0, soma_z0, soma_d, sec=soma)
    #
    h.pt3dclear(sec=ais)
    ais_x0 = somaparts["xd"].values[0]
    ais_y0 = somaparts["yd"].values[0]
    ais_z0 = somaparts["zd"].values[0]
    ais_d = 4.0
    h.pt3dadd(ais_x0, ais_y0, ais_z0, ais_d, sec=ais)
    h.pt3dadd(ais_x0 - 15.0, ais_y0, ais_z0, ais_d, sec=ais)
    #
    h.pt3dclear(sec=axon)
    ax_x0 = ais_x0 - 15.0
    ax_y0 = ais_y0
    ax_z0 = ais_z0
    ax_d = 2.0
    h.pt3dadd(ax_x0, ax_y0, ax_z0, ax_d, sec=axon)
    h.pt3dadd(ax_x0 - 100.0, ax_y0, ax_z0, ax_d, sec=axon)
    #
    # now iterate over paths to figure out parents sections,
    # and assign pt3d data to dend sections
    paths = paths[paths["ptype"] == 1]
    paths.sort_values("pathid", inplace=True)
    paths.index = range(len(paths))
    for n in range(len(paths)):
        if paths["primary"].values[n] == 0:
            parentID = paths["startson"].values[n]
            # figure out which section is the current object
            currentid = paths["pathid"].values[n]
            SWCType = paths["swctype"].values[n]
            if SWCType == 1:  # soma
                Sec = soma
            elif SWCType == 2:  # axon
                Sec = axon
            elif SWCType == 3:  # basal dendrite
                row = proximals.loc[proximals["pathid"] == currentid]
                Sec = proximal[row.index[0]]
                # ------assign pt3d----------
                thisparts = proximalparts.loc[proximalparts["pathid"] == currentid]
                h.pt3dclear(sec=Sec)
                h.pt3dadd(
                    h.Vector(thisparts["xd"].values),
                    h.Vector(thisparts["yd"].values),
                    h.Vector(thisparts["zd"].values),
                    h.Vector(thisparts["r"].values),
                    sec=Sec,
                )
            elif SWCType == 0:  # other dendrites
                row = distals.loc[distals["pathid"] == currentid]
                Sec = distal[row.index[0]]
                # ------assign pt3d----------
                thisparts = distalparts.loc[distalparts["pathid"] == currentid]
                h.pt3dclear(sec=Sec)
                h.pt3dadd(
                    h.Vector(thisparts["xd"].values),
                    h.Vector(thisparts["yd"].values),
                    h.Vector(thisparts["zd"].values),
                    h.Vector(thisparts["r"].values),
                    sec=Sec,
                )
            # figure out which section is the parent
            parentrow = paths.loc[paths["pathid"] == parentID]
            parentrow = parentrow.index[0]
            SWCparent = paths["swctype"].values[parentrow]
            if SWCparent == 1:  # soma
                ParentSec = soma
            elif SWCparent == 2:  # axon (should not occur)
                ParentSec = axon
            elif SWCparent == 3:  # basal dendrite
                rownumber = proximals.loc[proximals["pathid"] == parentID]
                ParentSec = proximal[rownumber.index[0]]
            elif SWCparent == 0:  # other dendrite
                rownumber = distals.loc[distals["pathid"] == parentID]
                ParentSec = distal[rownumber.index[0]]
            if SWCType == 2:
                pass
            else:
                Sec.connect(ParentSec)  # sections are connected at the 1-end
    h.define_shape()
    return soma, ais, axon, proximal, distal


def load3D(cell="0119simple", minD=1.0, debug=False):
    """
    This function reads the data for a neuron and constructs a neuron model.
    It returns the build sections.
    The 3D information needs to be saved in a subfolder Cells in a .csv-file and
    a .swc-file generated by ImageJ - simple neurite tracer.

    In the swc file the types are number coded, in the csv file as names
    1-soma, 2-axon, 3-(basal)dendrite-> used for the proximal dendrite,
    0-undefined->used for the distal dendrite
    further specific structres can be added using other SWCtypes

    created by Thomas Künzel, 2019-06-28

    Modified from original code by Elisabeth Koert, 2018
    """

    # read the files:
    filename = "cells/" + cell + "/" + cell

    # csv file containing path infos
    name = filename + ".csv"
    paths = pd.read_csv(
        name, skip_blank_lines=False, error_bad_lines=False, na_filter=False
    )

    # split infos
    somas = paths.loc[paths["SWCType"] == "soma"]
    somas.index = range(len(somas))
    axons = paths.loc[paths["SWCType"] == "axon"]
    axons.index = range(len(axons))
    proximals = paths.loc[paths["SWCType"] == "(basal) dendrite"]
    proximals.index = range(len(proximals))
    distals = paths.loc[paths["SWCType"] == "undefined"]
    distals.index = range(len(distals))

    # swc file containing infos on the single steps/parts of the paths
    columns = ["id", "type", "x", "y", "z", "d", "id2"]
    name = filename + ".swc"
    parts = pd.read_csv(
        name,
        names=columns,
        skiprows=6,
        header=None,
        error_bad_lines=False,
        delimiter=" ",
    )
    somaparts = parts.loc[parts["type"] == 1].copy()
    axonparts = parts.loc[parts["type"] == 2].copy()
    proximalparts = parts.loc[parts["type"] == 3].copy()
    distalparts = parts.loc[parts["type"] == 0].copy()
    axonparts.loc[axonparts.d < minD, "d"] = minD
    proximalparts.loc[proximalparts.d < minD, "d"] = minD
    distalparts.loc[distalparts.d < minD, "d"] = minD

    # create sections
    soma = h.Section(name="soma")
    soma.nseg = 7
    ais = h.Section(name="ais")
    ais.nseg = 3
    axon = h.Section(name="axon")
    axon.nseg = 11
    proximal = []
    for i in range(len(proximals["PathID"])):
        Sec = h.Section(name="prox" + str(i))
        Sec.nseg = 5
        proximal.append(Sec)
    distal = []
    for i in range(len(distals["PathID"])):
        Sec = h.Section(name="dist" + str(i))
        Sec.nseg = 5
        distal.append(Sec)
    # shape soma:
    loc = paths.loc[paths["PathName"] == "somaD"]
    somaD = loc["PathLength"].values[0]

    # connect Sections
    for n in range(len(paths)):
        if paths["PrimaryPath"].values[n] == False:
            parentID = paths["StartsOnPath"].values[n]
            if parentID:
                start = True  # just to enable the else, not very pretty code
            else:
                parentID = paths["EndsOnPath"].values[n]
            # figure out which section is the current object
            currentid = paths["PathID"].values[n]
            SWCType = paths["SWCType"].values[n]
            if SWCType == "soma":
                Sec = soma
            elif SWCType == "axon":  ##we attach an "artifical axon"
                Sec = axon
            elif SWCType == "(basal) dendrite":
                rownumber = proximals.loc[proximals["PathID"] == currentid]
                Sec = proximal[rownumber.index[0]]
            elif SWCType == "undefined":
                rownumber = distals.loc[distals["PathID"] == currentid]
                Sec = distal[rownumber.index[0]]
            # figure out which section is the parent
            parentrow = paths.loc[paths["PathID"] == int(parentID)]
            parentrow = parentrow.index[0]
            SWCparent = paths["SWCType"].values[parentrow]
            if SWCparent == "soma":
                ParentSec = soma
            elif SWCparent == "axon":
                ParentSec = axon
            elif SWCparent == "(basal) dendrite":
                rownumber = proximals.loc[proximals["PathID"] == int(parentID)]
                ParentSec = proximal[rownumber.index[0]]
            elif SWCparent == "undefined":
                rownumber = distals.loc[distals["PathID"] == int(parentID)]
                ParentSec = distal[rownumber.index[0]]
            if SWCType == "axon":
                pass
            else:
                Sec.connect(ParentSec)  # sections are connected at the 1-end
                # Sec.connect(ParentSec(1), 0)#sections are connected at the 1-end
    ais.connect(soma, 0)
    axon.connect(ais, 1)

    ###############A BIT HACKISH#################
    # now attach an "artificial" soma axon to the model for comparability with
    # the ball and stick model! This allows for isolated analysis of the dendrite
    h.pt3dclear(sec=soma)
    soma_x0 = somaparts["x"].values[0]
    soma_y0 = somaparts["y"].values[0]
    soma_z0 = somaparts["z"].values[0]
    soma_d = 19.5
    # for i in range(len(somaparts['id'])):
    #    x=somaparts['x'].values[i]
    #    y=somaparts['y'].values[i]
    #    z=somaparts['z'].values[i]
    #    #d=somaparts['d'].values[i]
    #    d=somaD
    #    h.pt3dadd(x,y,z,d,sec=soma)
    h.pt3dadd(soma_x0, soma_y0, soma_z0, soma_d, sec=soma)
    h.pt3dadd(soma_x0 + 19.5, soma_y0, soma_z0, soma_d, sec=soma)

    h.pt3dclear(sec=ais)
    ais_x0 = somaparts["x"].values[0]
    ais_y0 = somaparts["y"].values[0]
    ais_z0 = somaparts["z"].values[0]
    ais_d = 4.0
    h.pt3dadd(ais_x0, ais_y0, ais_z0, ais_d, sec=ais)
    h.pt3dadd(ais_x0 - 15.0, ais_y0, ais_z0, ais_d, sec=ais)

    h.pt3dclear(sec=axon)
    ax_x0 = ais_x0 - 15.0
    ax_y0 = ais_y0
    ax_z0 = ais_z0
    ax_d = 2.0
    h.pt3dadd(ax_x0, ax_y0, ax_z0, ax_d, sec=axon)
    h.pt3dadd(ax_x0 - 100.0, ax_y0, ax_z0, ax_d, sec=axon)
    ###############A BIT HACKISH#################
    #    for i in range(len(axonparts['id'])):
    #        x=axonparts['x'].values[i]
    #        y=axonparts['y'].values[i]
    #        z=axonparts['z'].values[i]
    #        d=axonparts['d'].values[i]
    #        h.pt3dadd(x,y,z,d,sec=axon)

    # assignment of pt3d data seems wrong to me. what should be done:
    # find startcoordinates from csv table
    # use first and last column to identify lines that belong

    for j in range(len(proximal)):
        h.pt3dclear(sec=proximal[j])
        for i in range(len(proximalparts["id"]) // len(proximal)):
            print(str(i + j * len(proximalparts["id"]) // len(proximal)))
            x = proximalparts["x"].values[
                i + j * len(proximalparts["id"]) // len(proximal)
            ]
            y = proximalparts["y"].values[
                i + j * len(proximalparts["id"]) // len(proximal)
            ]
            z = proximalparts["z"].values[
                i + j * len(proximalparts["id"]) // len(proximal)
            ]
            d = proximalparts["d"].values[
                i + j * len(proximalparts["id"]) // len(proximal)
            ]
            h.pt3dadd(x, y, z, d, sec=proximal[j])

    for j in range(len(distal)):
        h.pt3dclear(sec=distal[j])
        for i in range(len(distalparts["id"]) // len(distal)):
            x = distalparts["x"].values[i + j * len(distalparts["id"]) // len(distal)]
            y = distalparts["y"].values[i + j * len(distalparts["id"]) // len(distal)]
            z = distalparts["z"].values[i + j * len(distalparts["id"]) // len(distal)]
            d = distalparts["d"].values[i + j * len(distalparts["id"]) // len(distal)]
            h.pt3dadd(x, y, z, d, sec=distal[j])
    h.define_shape()
    return soma, ais, axon, proximal, distal


# ===============================================================================


def SE_3D(
    S,
    Simdur=400.0,
    dt=0.01,
    G_EoH=0.055,
    StochasticEoH=True,
    N=32,
    G_Dend=0.032,
    tau_Dend=2.0,
    gKLT_d=0.0085,
    gIH_d=0.001,
    gLEAK_d=0.001,  # here was 0.0001, 10x the Rm of the stylized? That seemed wrong (TK)
    gKLT_s=0.017,
    gIH_s=0.002,
    cell=1,
    debug=False,
    EoHseed=-1,
    somaticsynapsesonly=0,
    impedancetesting=0,
    impstim=(0.1, 50.0, 0.0),
    Ra=150.0,
    impdendtype=0,
    impdendid=-1,
    listinfo=False,
    minD=1.0,
):
    """
    Build one of the reconstructed gerbil SBC and give them biophysics.

    0: The "Ycell" (cell 0) is a dummy cell.
    1: SBC 1220
    2: SBC 0119
    3: SBC 1220b
    4: SBC 0119 simplified (was used for debugging the 3D geometry)

    Input Spiketimes are generated outside. Remember, you need N+1 spiketrains
    for the synapses (N x dendritic + endbulb)

    If you pass somaticsynapsesonly=1 then all the small synapses will be located on
    the soma (as requested by reviewer 2 for the JNP submission)

    If you pass impedancetesting=1, than a single current source will be attached to
    the distal end of a distal dendrite and a sinusoidal current of
    impstim[0] Amplitude,impstim[1] frequency and impstim[2] phase will be played.
    No synaptic events will occur in this case.
    If you pass impedancetesting=-1, than the same as above but a chirp stim is used
    which will defined by impfreq[0]->impfreq[1].
    impdendtype (default = 0): 0-> connect distal dendrite, 1->proximal dendrite
    imdendid (default = -1): which dendrite of type impdendtype to connect

    Modified from original code by Elisabeth Koert, 2018
    created by Thomas Künzel, 2019-06-28
    modified by Thomas Künzel, sept 2020
    """
    pretime = 100.0  # ms
    #
    # Check for impedancetesting and if the user wants it, blank all synaptic inputs
    if impedancetesting == 1 or impedancetesting == -1:
        G_Dend = 0.0
        G_EoH = 0.0
        from scipy.signal import chirp
    #
    if cell == 0:
        cellname = "Ycell"
    elif cell == 1:
        cellname = "1220"
    elif cell == 2:
        cellname = "0119"
    elif cell == 3:
        cellname = "1220b"
    elif cell == 4:
        cellname = "0119simple"
    #
    # create the model
    # soma, ais, axon, proximal, distal = load3D(
    #    cell=cellname, debug=debug
    # )  # see function above
    soma, ais, axon, proximal, distal = load3Dnew(
        cell=cellname,
        debug=debug,
        minD=minD,
    )
    if listinfo:
        nprox = len(proximal)
        ndist = len(distal)
        return nprox, ndist
    # axial Resistance and cm
    for sec in h.allsec():
        sec.Ra = Ra
        sec.insert("extracellular")
    axon.cm = 0.1
    # na
    soma.insert("na_fast")
    soma.ena = 50
    soma.gnabar_na_fast = 0.01  # old ball and stick value was 1e-9
    ais.insert("na_fast")
    ais.ena = 50
    ais.gnabar_na_fast = 0.53
    # klt
    soma.insert("klt")
    soma.ek = -70
    soma.gkltbar_klt = gKLT_s
    ais.insert("klt")
    ais.ek = -70
    ais.gkltbar_klt = gKLT_s
    # kht
    soma.insert("kht")
    soma.gkhtbar_kht = 0.013
    ais.insert("kht")
    ais.ek = -70
    ais.gkhtbar_kht = 0.013
    # ih
    soma.insert("ih")
    h.eh_ih = -43
    soma.ghbar_ih = gIH_s
    for i in range(len(proximal)):
        proximal[i].insert("ih")
        proximal[i].ghbar_ih = gIH_d
        proximal[i].insert("klt")
        proximal[i].gkltbar_klt = gKLT_d
    # leak
    for sec in h.allsec():
        sec.insert("leak")
        sec.erev_leak = -65
        sec.g_leak = gLEAK_d
    axon.g_leak = 0.0001
    # GENERAL SETTINGS
    h.dt = dt  # simulation (or "sampling") rate
    h.celsius = 35  # simulation global temperature
    # shape the endbulb input
    EoH_Template = seh.g_template(dt=dt, gmax=G_EoH)
    g_exc = seh.make_g_trace(
        Simdur + pretime, dt, S[-1] + pretime, EoH_Template, StochasticEoH, 0.1, EoHseed
    )  # Last spiketimes are for endbulbs
    gv_exc = h.Vector(g_exc)
    endbulb = h.GClamp(0.4, sec=soma)
    endbulb.e = 0
    gv_exc.play(endbulb._ref_g, h.dt)
    # sloc file containing locations for "randomly" placed synapses -- so they
    # are more reproducible
    slocfilename = "./cells/" + cellname + "/" + cellname + ".npy"
    if os.path.isfile(slocfilename):
        has_sloc = True
        try:
            sloc = np.load(slocfilename, allow_pickle=True)
        except:
            has_sloc = False
        if sloc.shape[0] != N:
            has_sloc = False
    else:
        has_sloc = False
    if not has_sloc:
        sloc = np.zeros((N, 4))
    # shape the small synapses
    if N != 0:
        vstim = []
        syna = []
        netcon = []
        G_i = G_Dend / N  # individual conductance
        pos = np.linspace(0.05, 0.95, N)
        for a in range(N):
            if somaticsynapsesonly == 1:
                syna.append(h.ExpSyn(soma(pos[a])))
                syna[a].tau = tau_Dend
            else:
                # define synapse position randomly or from file:
                if has_sloc:
                    onproximal = bool(sloc[a, 0])
                    thispos = sloc[a, 1]
                    whichdistal = int(sloc[a, 2])
                    whichproximal = int(sloc[a, 3])
                else:
                    if np.random.random() > 0.66:
                        onproximal = True
                    else:
                        onproximal = False
                    thispos = np.random.random()  # random position on dendrite
                    whichdistal = np.random.randint(
                        0, len(distal) - 1
                    )  # random distal dendrite
                    whichproximal = np.random.randint(
                        0, len(proximal) - 1
                    )  # random distal dendrite
                    sloc[a, 0] = float(onproximal)
                    sloc[a, 1] = thispos
                    sloc[a, 2] = float(whichdistal)
                    sloc[a, 3] = float(whichproximal)
                if onproximal:
                    syna.append(h.ExpSyn(proximal[whichproximal](thispos)))
                    syna[a].tau = tau_Dend
                else:
                    syna.append(h.ExpSyn(distal[whichdistal](thispos)))
                    syna[a].tau = tau_Dend
            # synapse stimulieren
            vstim.append(h.VecStim())
            netcon.append(h.NetCon(vstim[a], syna[a]))  # connect stimulus and synapse
            netcon[a].weight[0] = G_i
            spt = h.Vector(S[a] + pretime)
            vstim[a].play(spt)
    if not has_sloc:
        if not somaticsynapsesonly == 1:
            np.save(slocfilename, sloc)
    #
    # Input for impedance testing (as requested by reviewer)
    if impedancetesting == 1 or impedancetesting == -1:
        if impdendtype == 0:
            impclamp = h.IClamp(distal[impdendid](0.99))
            impathlen = h.distance(soma(0.5), distal[impdendid](0.99))
        else:
            impclamp = h.IClamp(proximal[impdendid](0.99))
            impathlen = h.distance(soma(0.5), proximal[impdendid](0.99))
        impclamp.delay = 0.0
        impclamp.dur = 1e9
        impclamp.amp = 0.0
        if impedancetesting == -1:
            t = np.linspace(0.0, Simdur - dt, int(Simdur / dt))
            tsec = t / 1000.0
            impwave = impstim[0] * chirp(
                tsec,
                f0=impstim[1][0],
                f1=impstim[1][1],
                t1=tsec[-1],
                method="linear",
            )
        else:
            t = np.linspace(0.0, Simdur - dt, int(Simdur / dt))
            f = impstim[1] / 1000.0
            impwave = impstim[0] * np.sin(2.0 * np.pi * f * t + impstim[2])
        prezeros = np.zeros(int(round(pretime / dt)))
        impwave = np.concatenate((prezeros, impwave))
        impwave = h.Vector(impwave)
        tvec = np.linspace(0.0, (Simdur + pretime) - dt, (Simdur + pretime) / dt)
        tvec = h.Vector(tvec)
        impwave.play(impclamp._ref_amp, tvec)
    else:
        impathlen = -1
    #
    if debug:
        from neuron import gui

        basename = "figs/shape"
        s = h.Shape()
        s.show(0)
        s.color(2, sec=soma)
        s.color(2, sec=axon)
        s.color(2, sec=ais)
        for pcount, thisprox in enumerate(proximal):
            s.color(3 + pcount, sec=thisprox)
        if impedancetesting == 1:
            s.point_mark(impclamp, 3)
            s.label(0, 0, str(impathlen))
            varname = "_c" + str(cell) + "_t" + str(impdendtype) + "_d" + str(impdendid)
            filename = basename + varname + ".ps"
        else:
            varname = "_c" + str(cell) + "_syn"
            filename = basename + varname + ".ps"
            for a in range(N):
                s.point_mark(syna[a], 3)
        # input("Press Enter to continue...")###uncomment if you want interactive plot
        s.printfile(filename)
    #
    # INFRASTRUCTURE
    Vm = h.Vector()
    Vm.record(soma(0.5)._ref_v)
    #
    # ----------SIMULATE--------------
    h.finitialize(-63.79)
    h.fcurrent()
    while h.t < Simdur + pretime:
        h.fadvance()
    #
    # PACK AND EXPORT DATA
    Result = {}
    tempres_vm = np.array(Vm)
    Result["Vm"] = tempres_vm[
        int(pretime / dt) : int((Simdur + pretime) / dt)
    ]  # remove "additional" samples
    Result["impathlen"] = impathlen
    #
    # ---------SAY GOODBYE-------------
    return Result
