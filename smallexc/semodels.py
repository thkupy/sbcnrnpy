#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Thu May 16 10:09:28 2019
This module contains the functions concerned with running the various SBC models
for the dendritic input project
@author: Thomas Kuenzel (kuenzel{at}bio2.rwth-aachen.de)
"""
import numpy as np
import smallexc.sehelper as seh
import pandas as pd
from neuron import h
import os
h.nrn_load_dll("./mechanisms/x86_64/.libs/libnrnmech.so")

#===============================================================================

def SE_BS(S,Simdur=400.0,dt=0.01,G_EoH=0.055,StochasticEoH=True,
          N=32,G_Dend=0.016,tau_Dend=2.0,L=50,D=3,constR=False,
          gKLT_d=0.0085,gIH_d=0.001,gLEAK_d=0.001,
          gKLT_s=0.017,gIH_s=0.002,EoHseed=-1):
    """
    1.builds an SBC with a soma, a proximal (dend1) and distal (dend2) dendrite
    and an somatic input (endbulb) and gives it biophysical parameters
    2.generates a GClamp input for the endbulb
    3.build synapses with netcon, spikes generated by a sound, and stimulates
    """
    pretime = 100.0#ms

    # CREATE MODEL SECTIONS
    BCsoma = h.Section()
    BCaxonhillock = h.Section()
    BCaxonsegment = h.Section()
    dend1 = h.Section()
    dend2 = h.Section()

    # SECTION SETTINGS
    #dimensions
    BCsoma.L = 19.5
    BCsoma.diam = 19.5
    BCsoma.nseg = 9
    BCaxonhillock.L = 15
    BCaxonhillock.diam = 4
    BCaxonhillock.nseg = 3
    BCaxonsegment.L = 100
    BCaxonsegment.diam = 2
    BCaxonsegment.nseg = 10

    ###add dendrites
    dend1.L = L
    dend1.diam = D
    dend1.nseg = 21#int(L)
    dend2.L = 50
    dend2.diam = 3
    dend2.nseg = 100
    #-----------get R of dend1 (for debug purposes)
    d1A=0.0
    for seg in dend1.allseg():#this is save for 3d data
        d1A=d1A+seg.area()

    #axial Resistance and cm
    for sec in h.allsec():
        sec.Ra = 150
        sec.insert('extracellular')
    BCaxonsegment.cm = 0.1
    #na---------------------------------------------
    BCsoma.insert('na_fast')
    BCsoma.ena = 50
    BCsoma.gnabar_na_fast = 0.01
    BCaxonhillock.insert('na_fast')
    BCaxonhillock.ena = 50
    BCaxonhillock.gnabar_na_fast = 0.53
    #klt---------------------------------------------
    BCsoma.insert('klt')
    BCsoma.ek = -70
    BCsoma.gkltbar_klt = gKLT_s
    dend1.insert('klt')
    if constR:
        dend1.gkltbar_klt =(0.15/d1A)*(gKLT_d*1000.0)
    else:
        dend1.gkltbar_klt =gKLT_d
    #kht---------------------------------------------
    BCsoma.insert('kht')
    BCsoma.gkhtbar_kht = 0.013
    BCaxonhillock.insert('kht')
    BCaxonhillock.ek = -70
    BCaxonhillock.gkhtbar_kht = 0.01
    #ih---------------------------------------------
    BCsoma.insert('ih')
    h.eh_ih = -43
    BCsoma.ghbar_ih = gIH_s
    dend1.insert('ih')
    if constR:
        dend1.ghbar_ih =(0.15/d1A)*(gIH_d*1000.0)
    else:
        dend1.ghbar_ih = gIH_d
    #leak---------------------------------------------
    BCsoma.insert('leak')
    BCsoma.erev_leak = -65
    BCsoma.g_leak = 0.001
    BCaxonhillock.insert('leak')
    BCaxonhillock.erev_leak = -65
    BCaxonhillock.g_leak = 0.001
    BCaxonsegment.insert('leak')
    BCaxonsegment.erev_leak = -65
    BCaxonsegment.g_leak = 0.0001
    dend1.insert('leak')
    dend1.erev_leak = -65
    if constR:
        dend1.g_leak = 0.15/d1A*(gLEAK_d*1000.0)
    else:
        dend1.g_leak = gLEAK_d
    dend2.insert('leak')
    dend2.erev_leak = -65
    dend2.g_leak = 0.001

     # CONNECT SECTIONS (soma0-soma1..ah0-ah1..ax0-ax1)
    BCaxonsegment.connect(BCaxonhillock,1,0)
    BCaxonhillock.connect(BCsoma,1,0)
    BCsoma.connect(dend1,1,0)
    dend1.connect(dend2,1,0)

    # GENERAL SETTINGS
    h.dt = dt  # simulation (or "sampling") rate
    h.celsius = 35# simulation global temperature

    # MODEL NEURON INPUTS
    if G_EoH != 0.0:
        g_exc=seh.make_g_trace(Simdur+pretime,dt,S[-1]+pretime,seh.g_template(dt=dt,gmax=G_EoH),StochasticEoH,0.1,EoHseed)#Last spiketimes are for endbulbs
        exc = h.Vector(g_exc)
        endbulb = h.GClamp(0.4, sec=BCsoma)
        endbulb.e = 0
        exc.play(endbulb._ref_g,h.dt)
    #ab hier synapsen anhängen
    if N!=0:
        vstim = []
        syna = []
        netcon = []
        G_i = G_Dend/N # individual conductance
        pos=np.linspace(0.05,0.95,N)#distributed along the dendrite
        for a in range(N):
            syna.append(h.ExpSyn(dend2(pos[a])))
            syna[a].tau = tau_Dend
            vstim.append(h.VecStim())
            netcon.append(h.NetCon(vstim[a],syna[a]))#connect stimulus and synapse
            netcon[a].weight[0]= G_i
            spt = h.Vector(S[a]+pretime)
            vstim[a].play(spt)

    # INFRASTRUCTURE
    Vm = h.Vector()
    Vm.record(BCsoma(0.5)._ref_v)

    #----------SIMULATE--------------
    h.finitialize(-63.79)
    h.fcurrent()
    while h.t<Simdur+pretime:
        h.fadvance()

    # PACK AND EXPORT DATA
    Result = {}
    tempres_vm = np.array(Vm)
    Result['Vm'] = tempres_vm[int(pretime/dt):int((Simdur+pretime)/dt)] #remove "additional" samples

    #some debug info
    g_total_dend1 = dend1.g_leak+dend1.ghbar_ih+dend1.gkltbar_klt#S/cm²
    g_total_dend1 = g_total_dend1 * (d1A*1e-8)*1e9

    #---------KILL STUFF FOR (minimal) PERFORMANCE REASONS---------------------
    netcon = None
    vstim = None
    syna = None
    Vm = None
    spt = None
    BCaxonsegment = None
    BCaxonhillock = None
    BCsoma = None
    dend1 = None
    dend2 = None

    #---------SAY GOODBYE-------------
    return(Result)

#===============================================================================
#===========================3D SBC Code below===================================
#===============================================================================

def load3D(cell='Ycell',minD=1.0,debug=False):
    '''
    This function reads the data for a neuron and constructs a neuron model. 
    It returns the build sections.
    The 3D information needs to be saved in a subfolder Cells in a .csv-file and
    a .swc-file generated by ImageJ - simple neurite tracer.
    
    In the swc file the types are number coded, in the csv file as names 
    1-soma, 2-axon, 3-(basal)dendrite-> used for the proximal dendrite, 0-undiefined->used for the distal dendrite
    further specific structres can be added using other SWCtypes
    
    created by Thomas Kuenzel, 2019-06-28 (kuenzel{at}bio2.rwth-aachen.de)
    Modified from original code by Elisabeth Koert, 2018
    '''	
    
    #read the files:
    filename='cells/'+cell+'/'+cell

    #csv file containing path infos
    name=filename+'.csv'
    paths=pd.read_csv(name,skip_blank_lines=False,error_bad_lines=False,na_filter=False)

    #split infos
    somas=paths.loc[paths['SWCType'] == 'soma']
    somas.index=range(len(somas))
    axons=paths.loc[paths['SWCType'] == 'axon']
    axons.index=range(len(axons))
    proximals=paths.loc[paths['SWCType'] == '(basal) dendrite']
    proximals.index=range(len(proximals))
    distals=paths.loc[paths['SWCType'] == 'undefined']
    distals.index=range(len(distals))

    #swc file containing infos on the single steps/parts of the paths
    collums=['id','type','x','y','z','d','id2']
    name=filename+'.swc'
    parts=pd.read_csv(name,names=collums,skiprows=6,header=None,error_bad_lines=False, delimiter=" ")
    somaparts=parts.loc[parts['type'] == 1].copy()
    axonparts=parts.loc[parts['type'] == 2].copy()
    proximalparts=parts.loc[parts['type'] == 3].copy()
    distalparts=parts.loc[parts['type'] == 0].copy()
    axonparts.loc[axonparts.d < minD, 'd'] = minD
    proximalparts.loc[proximalparts.d < minD, 'd'] = minD
    distalparts.loc[distalparts.d < minD, 'd'] = minD
    
    #create sections
    soma=h.Section(name='soma')
    soma.nseg = 7
    ais=h.Section(name='ais')
    ais.nseg = 3
    axon=h.Section(name='axon')
    axon.nseg = 11
    proximal=[] 
    for i in range(len(proximals['PathID'])):		
        Sec=h.Section(name='prox'+str(i))
        Sec.nseg = 5
        proximal.append(Sec)
    distal=[]
    for i in range(len(distals['PathID'])):		
        Sec=h.Section(name='dist'+str(i))
        Sec.nseg = 5
        distal.append(Sec)
    #shape soma:
    loc=paths.loc[paths['PathName'] == 'somaD']
    somaD= loc['PathLength'].values[0]

    #connect Sections
    for n in range(len(paths)):
        if paths['PrimaryPath'].values[n]==False:
            parentID=paths['StartsOnPath'].values[n]
            if parentID:
                start=True #just to enable the else, not very pretty code
            else:
                parentID=paths['EndsOnPath'].values[n]

            #figure out which section is the current object
            currentid=paths['PathID'].values[n]
            SWCType=paths['SWCType'].values[n]
            if SWCType=='soma':
                Sec=soma
            elif SWCType=='axon': ##we attach an "artifical axon"
                Sec=axon
            elif SWCType=='(basal) dendrite':
                rownumber=proximals.loc[proximals['PathID']==currentid]
                Sec=proximal[rownumber.index[0]]
            elif SWCType=='undefined':
                rownumber=distals.loc[distals['PathID']==currentid]
                Sec=distal[rownumber.index[0]]
            #figure out which section is the parent
            parentrow=paths.loc[paths['PathID']==int(parentID)]
            parentrow=parentrow.index[0]
            SWCparent=paths['SWCType'].values[parentrow]
            if SWCparent=='soma':
                ParentSec=soma
            elif SWCparent=='axon':
                ParentSec=axon
            elif SWCparent=='(basal) dendrite':
                rownumber=proximals.loc[proximals['PathID']==int(parentID)]
                ParentSec=proximal[rownumber.index[0]]
            elif SWCparent=='undefined':
                rownumber=distals.loc[distals['PathID']==int(parentID)]
                ParentSec=distal[rownumber.index[0]]
            if SWCType=='axon':
                pass
                #Sec.connect(ParentSec,0)#axon is on the 0-end
            else:
                Sec.connect(ParentSec,1)#all other sections are connected at the 1-end
    ais.connect(soma,0)
    axon.connect(ais,1)

    #now attach an "artificial" soma axon to the model for comparability with
    #the ball and stick model! This allows for isolated analysis of the dendrite
    h.pt3dclear(sec=soma)
    soma_x0 = somaparts['x'].values[0]
    soma_y0 = somaparts['y'].values[0]
    soma_z0 = somaparts['z'].values[0]
    soma_d = 19.5
    h.pt3dadd(soma_x0,soma_y0,soma_z0,soma_d,sec=soma)
    h.pt3dadd(soma_x0+19.5,soma_y0,soma_z0,soma_d,sec=soma)

    h.pt3dclear(sec=ais)
    ais_x0=somaparts['x'].values[0]
    ais_y0=somaparts['y'].values[0]
    ais_z0=somaparts['z'].values[0]
    ais_d=4.0
    h.pt3dadd(ais_x0,ais_y0,ais_z0,ais_d,sec=ais)
    h.pt3dadd(ais_x0-15.0,ais_y0,ais_z0,ais_d,sec=ais)
    
    h.pt3dclear(sec=axon)
    ax_x0=ais_x0-15.0
    ax_y0=ais_y0
    ax_z0=ais_z0
    ax_d=2
    h.pt3dadd(ax_x0,ax_y0,ax_z0,ax_d,sec=axon)
    h.pt3dadd(ax_x0-100.0,ax_y0,ax_z0,ax_d,sec=axon)
    
    for j in range(len(proximal)):
        h.pt3dclear(sec=proximal[j])
        for i in range(len(proximalparts['id'])/len(proximal)):
            x=proximalparts['x'].values[i+j*len(proximalparts['id'])/len(proximal)]
            y=proximalparts['y'].values[i+j*len(proximalparts['id'])/len(proximal)]
            z=proximalparts['z'].values[i+j*len(proximalparts['id'])/len(proximal)]
            d=proximalparts['d'].values[i+j*len(proximalparts['id'])/len(proximal)]
            h.pt3dadd(x,y,z,d,sec=proximal[j])
            
    for j in range(len(distal)):
        h.pt3dclear(sec=distal[j])
        for i in range(len(distalparts['id'])/len(distal)):
            x=distalparts['x'].values[i+j*len(distalparts['id'])/len(distal)]
            y=distalparts['y'].values[i+j*len(distalparts['id'])/len(distal)]
            z=distalparts['z'].values[i+j*len(distalparts['id'])/len(distal)]
            d=distalparts['d'].values[i+j*len(distalparts['id'])/len(distal)]
            h.pt3dadd(x,y,z,d,sec=distal[j])
    h.define_shape()
    return soma, ais, axon, proximal, distal

#===============================================================================

def SE_3D(S,Simdur=400.0,dt=0.01,G_EoH=0.075,StochasticEoH=True,
          N=32,G_Dend=0.032,tau_Dend=2.0,
          gKLT_d=0.0085,gIH_d=0.001,gLEAK_d=0.0001,
          gKLT_s=0.017,gIH_s=0.002,
          cell=0,
          debug=False,
          EoHseed=-1):
    '''
    Build one of the reconstructed gerbil SBC and give them
    biophysics.
    
    0: The "Ycell" (cell 0) is a dummy cell.
    1: SBC 1220
    2: SBC 0119
    (more will be added here later)
    
    Input Spiketimes are generated outside. Remember, you need N+1 spiketrains 
    for the synapses (N x dendritic + endbulb)
    created by Thomas Kuenzel, 2019-06-28 (kuenzel{at}bio2.rwth-aachen.de)
        
    Modified from original code by Elisabeth Koert, 2018
    '''
    pretime = 100.0#ms
    
    if cell == 0:
        cellname = 'Ycell'
    elif cell == 1:
        cellname= '1220'
    elif cell == 2:
        cellname = '0119'
    
    #create the model
    soma, ais, axon, proximal, distal=load3D(cell=cellname,debug=debug)#see function above
    
    '''
    now add the biophysics of the gerbil SBC model,
    since the somatic volume is more thant the double of the ball and stick 
    model, a higher density of voltage activated channels in the soma is needed
    
    created by Thomas Kuenzel, 2019-06-28 (kuenzel{at}bio2.rwth-aachen.de)
        
    Modified from original code by Elisabeth Koert, 2018
    '''
    #axial Resistance and cm
    for sec in h.allsec():
        sec.Ra = 150
        sec.insert('extracellular')
    axon.cm = 0.1
    #na
    soma.insert('na_fast')
    soma.ena = 50
    soma.gnabar_na_fast = 0.01 #old ball and stick value was 1e-9
    
    ais.insert('na_fast')
    ais.ena = 50
    ais.gnabar_na_fast = 0.53
    
    #klt
    soma.insert('klt')
    soma.ek = -70
    soma.gkltbar_klt = gKLT_s
    ais.insert('klt')
    ais.ek = -70
    ais.gkltbar_klt = gKLT_s
    #kht
    soma.insert('kht')
    soma.gkhtbar_kht = 0.013
    ais.insert('kht')
    ais.ek = -70
    ais.gkhtbar_kht = 0.013
    #ih
    soma.insert('ih')
    h.eh_ih = -43
    soma.ghbar_ih = gIH_s
    for i in range(len(proximal)):
        proximal[i].insert('ih')
        proximal[i].ghbar_ih =gIH_d
        proximal[i].insert('klt')
        proximal[i].gkltbar_klt=gKLT_d
    #leak
    for sec in h.allsec():
        sec.insert('leak')
        sec.erev_leak=-65
        sec.g_leak=gLEAK_d
    axon.g_leak = 0.0001
    # GENERAL SETTINGS
    h.dt = dt  # simulation (or "sampling") rate
    h.celsius = 35  # simulation global temperature
    
    #shape the endbulb input
    EoH_Template=seh.g_template(dt=dt,gmax=G_EoH)
    g_exc=seh.make_g_trace(Simdur+pretime,dt,S[-1]+pretime,EoH_Template,StochasticEoH,0.1,EoHseed)#Last spiketimes are for endbulbs
    gv_exc = h.Vector(g_exc)
    endbulb = h.GClamp(0.4, sec=soma)
    endbulb.e = 0
    gv_exc.play(endbulb._ref_g,h.dt)
    
    #sloc file containing locations for "randomly" placed synapses -- so they
    #are more reproducible
    slocfilename='./cells/'+cellname+'/'+cellname+'.npy'
    if os.path.isfile(slocfilename):
        has_sloc = True
        sloc = np.load(slocfilename, allow_pickle=True)
        if sloc.size != N:
            has_sloc = False
    else:
        has_sloc = False
    if not has_sloc:
        sloc = np.zeros((N,4))

    #shape the small synapses
    if N!=0:
        vstim = []
        syna = []
        netcon = []
        G_i = G_Dend/N # individual conductance
        for a in range(N):
            #define synapse position randomly or from file:
            if has_sloc:
                onproximal = bool(sloc[a,0])
                thispos = sloc[a,1]
                whichdistal = int(sloc[a,2])
                whichproximal = int(sloc[a,3])
            else:
                if np.random.random() > 0.66:
                    onproximal = True
                else:
                    onproximal = False
                thispos=np.random.random() #random position on dendrite
                whichdistal=np.random.randint(0,len(distal)-1) #random distal dendrite
                whichproximal=np.random.randint(0,len(proximal)-1) #random distal dendrite
                sloc[a,0]=float(onproximal)
                sloc[a,1]=thispos
                sloc[a,2]=float(whichdistal)
                sloc[a,3]=float(whichproximal)
            if onproximal:
                syna.append(h.ExpSyn(proximal[whichproximal](thispos)))#neue Synapse
                syna[a].tau = tau_Dend
            else:
                syna.append(h.ExpSyn(distal[whichdistal](thispos)))#neue Synapse
                syna[a].tau = tau_Dend

            #synapse stimulieren
            vstim.append(h.VecStim())
            netcon.append(h.NetCon(vstim[a],syna[a]))#connect stimulus and synapse
            netcon[a].weight[0]= G_i
            spt = h.Vector(S[a])
            vstim[a].play(spt)
    if not has_sloc:
        np.save(slocfilename,sloc)

    if debug:
        from neuron import gui
        s = h.Shape()
        s.show(1)
        s.color(2, sec=soma) # color section "a" red
        for a in range(N):
            s.point_mark(syna[a],4)
        h.topology()
    
    # INFRASTRUCTURE
    Vm = h.Vector()
    Vm.record(soma(0.5)._ref_v)

    #----------SIMULATE--------------
    h.finitialize(-63.79)
    h.fcurrent()
    while h.t<Simdur+pretime:
        h.fadvance()

    # PACK AND EXPORT DATA
    Result = {}
    tempres_vm = np.array(Vm)
    Result['Vm'] = tempres_vm[int(pretime/dt):int((Simdur+pretime)/dt)] #remove "additional" samples
    
    if debug:
        raw_input('Press <ENTER> to continue')
    
    #---------SAY GOODBYE-------------
    return(Result)
